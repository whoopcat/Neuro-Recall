[
  {
    "question": "Bytecode",
    "answer": "An intermediate, platform-independent code generated by the Java compiler (.class file).",
    "explanation": "This code is interpreted/executed by the JVM, making Java 'Write Once, Run Anywhere'.",
    "category": "Java Fundamentals",
    "type": "flashcard"
  },
  {
    "question": "JVM (Java Virtual Machine)",
    "answer": "The engine that executes Java Bytecode by translating it into machine-specific code.",
    "explanation": "It provides the runtime environment and handles memory management (Garbage Collection).",
    "category": "Java Fundamentals",
    "type": "flashcard"
  },
  {
    "question": "Encapsulation",
    "answer": "The bundling of data (variables) and methods together, while restricting direct access to some of an object's components.",
    "explanation": "Achieved using 'private' variables and 'public' getters/setters.",
    "category": "Encapsulation",
    "type": "flashcard"
  },
  {
    "question": "Inheritance",
    "answer": "A mechanism where a new class (subclass) acquires the properties and behaviors of an existing class (superclass).",
    "explanation": "Represents an 'IS-A' relationship. Uses the 'extends' keyword.",
    "category": "Inheritance",
    "type": "flashcard"
  },
  {
    "question": "Polymorphism",
    "answer": "The ability of an object or method to take on many forms.",
    "explanation": "Includes Compile-time (Overloading) and Runtime (Overriding) polymorphism.",
    "category": "Polymorphism",
    "type": "flashcard"
  },
  {
    "question": "Abstraction",
    "answer": "Hiding complex implementation details and showing only the essential features of the object.",
    "explanation": "Achieved using Abstract Classes and Interfaces.",
    "category": "Abstraction",
    "type": "flashcard"
  },
  {
    "question": "Class",
    "answer": "A blueprint or template used to create objects, defining their properties and behaviors.",
    "explanation": "It is a logical entity, not a physical one (does not consume heap memory until instantiated).",
    "category": "OOP Basics",
    "type": "flashcard"
  },
  {
    "question": "Object",
    "answer": "A specific instance of a class that has state (fields) and behavior (methods).",
    "explanation": "Objects are allocated in Heap memory.",
    "category": "OOP Basics",
    "type": "flashcard"
  },
  {
    "question": "Constructor",
    "answer": "A special block of code initialized when an object is created, used to set initial values.",
    "explanation": "It has the same name as the class and no return type (not even void).",
    "category": "OOP Basics",
    "type": "flashcard"
  },
  {
    "question": "Default Constructor",
    "answer": "A no-argument constructor automatically provided by the Java compiler if no other constructor is defined.",
    "explanation": "It initializes variables to their default values (0, null, false).",
    "category": "OOP Basics",
    "type": "flashcard"
  },
  {
    "question": "super keyword",
    "answer": "A reference variable used to refer to the immediate parent class object.",
    "explanation": "Used to call parent constructors `super()` or access hidden parent methods/fields.",
    "category": "Inheritance",
    "type": "flashcard"
  },
  {
    "question": "this keyword",
    "answer": "A reference variable that points to the current object instance.",
    "explanation": "Commonly used to distinguish between instance variables and local parameters with the same name.",
    "category": "OOP Basics",
    "type": "flashcard"
  },
  {
    "question": "Method Overloading",
    "answer": "Defining multiple methods in the same class with the same name but different parameter lists.",
    "explanation": "This is Compile-time Polymorphism (Static Binding).",
    "category": "Polymorphism",
    "type": "flashcard"
  },
  {
    "question": "Method Overriding",
    "answer": "Providing a specific implementation in a subclass for a method already defined in its superclass.",
    "explanation": "This is Runtime Polymorphism (Dynamic Binding). Signatures must match exactly.",
    "category": "Polymorphism",
    "type": "flashcard"
  },
  {
    "question": "Abstract Class",
    "answer": "A class declared with 'abstract' that cannot be instantiated directly.",
    "explanation": "Can contain both abstract (no body) and concrete methods. Serves as a base for subclasses.",
    "category": "Abstraction",
    "type": "flashcard"
  },
  {
    "question": "Interface",
    "answer": "A contract that defines a set of methods a class must implement.",
    "explanation": "Supports Multiple Inheritance. All variables are implicitly `public static final`.",
    "category": "Interfaces",
    "type": "flashcard"
  },
  {
    "question": "Access Modifier: private",
    "answer": "The member is accessible only within the class it is declared.",
    "explanation": "This is the most restrictive level, essential for Encapsulation.",
    "category": "Encapsulation",
    "type": "flashcard"
  },
  {
    "question": "Access Modifier: protected",
    "answer": "The member is accessible within the same package and by subclasses in different packages.",
    "explanation": "Often used in inheritance hierarchies for game entities (e.g., allow Player to access Entity fields).",
    "category": "Encapsulation",
    "type": "flashcard"
  },
  {
    "question": "Access Modifier: default",
    "answer": "The member is accessible only within the same package. (Also known as package-private).",
    "explanation": "This is applied when no modifier is specified.",
    "category": "Encapsulation",
    "type": "flashcard"
  },
  {
    "question": "Access Modifier: public",
    "answer": "The member is accessible from any other class in the application.",
    "explanation": "Typically used for API methods or constants.",
    "category": "Encapsulation",
    "type": "flashcard"
  },
  {
    "question": "Static Binding",
    "answer": "The linking of a method call to the method body at compile time.",
    "explanation": "Applies to static, private, and final methods, as well as Overloading.",
    "category": "Polymorphism",
    "type": "flashcard"
  },
  {
    "question": "Dynamic Binding",
    "answer": "The linking of a method call to the method body at runtime based on the actual object type.",
    "explanation": "The mechanism behind Method Overriding.",
    "category": "Polymorphism",
    "type": "flashcard"
  },
  {
    "question": "Shallow Copy",
    "answer": "Creating a new object but copying the references of the fields from the original.",
    "explanation": "Default behavior of `clone()`. Changes to mutable fields in the copy affect the original.",
    "category": "Cloning",
    "type": "flashcard"
  },
  {
    "question": "Deep Copy",
    "answer": "Creating a new object and recursively creating copies of all objects referenced by the fields.",
    "explanation": "The copy and original are completely independent.",
    "category": "Cloning",
    "type": "flashcard"
  },
  {
    "question": "IS-A Relationship",
    "answer": "Represents Inheritance.",
    "explanation": "e.g., 'Dog IS-A Animal'. Implemented via `extends`.",
    "category": "Relationships",
    "type": "flashcard"
  },
  {
    "question": "HAS-A Relationship",
    "answer": "Represents Association (Aggregation or Composition).",
    "explanation": "e.g., 'Car HAS-A Engine'. Implemented by having a class instance as a field.",
    "category": "Relationships",
    "type": "flashcard"
  },
  {
    "question": "Composition",
    "answer": "A strong form of Association where the child cannot exist without the parent.",
    "explanation": "e.g., House and Room. If House is destroyed, Room is destroyed.",
    "category": "Relationships",
    "type": "flashcard"
  },
  {
    "question": "Aggregation",
    "answer": "A weak form of Association where the child can exist independently of the parent.",
    "explanation": "e.g., Library and Student. If Library closes, Student still exists.",
    "category": "Relationships",
    "type": "flashcard"
  },
  {
    "question": "Dependency",
    "answer": "A temporary relationship where one class uses another.",
    "explanation": "Often occurs when an object is passed as a parameter to a method but not stored as a field.",
    "category": "Relationships",
    "type": "flashcard"
  },
  {
    "question": "Checked Exception",
    "answer": "Exceptions checked at compile-time that must be handled (try-catch) or declared (throws).",
    "explanation": "e.g., IOException, SQLException.",
    "category": "Error Handling",
    "type": "flashcard"
  },
  {
    "question": "Unchecked Exception",
    "answer": "Exceptions that occur at runtime and are not checked by the compiler.",
    "explanation": "e.g., NullPointerException, ArithmeticException. Usually indicative of programming errors.",
    "category": "Error Handling",
    "type": "flashcard"
  },
  {
    "question": "finally block",
    "answer": "A block of code that executes after try/catch, regardless of whether an exception occurred.",
    "explanation": "Used for resource cleanup (closing files, scanners).",
    "category": "Error Handling",
    "type": "flashcard"
  },
  {
    "question": "String Pool",
    "answer": "A special area in Heap memory where String literals are stored to save memory.",
    "explanation": "Strings with the same content share the same reference in the pool.",
    "category": "Java Internals",
    "type": "flashcard"
  },
  {
    "question": "== vs .equals()",
    "answer": "'==' compares memory references; '.equals()' compares content (if overridden).",
    "explanation": "For Strings, always use .equals() to check if the text is the same.",
    "category": "Java Fundamentals",
    "type": "flashcard"
  },
  {
    "question": "final keyword (variable)",
    "answer": "The variable's value cannot be changed after initialization (it is a constant).",
    "explanation": "If it's a reference, the reference cannot change, but the object's state might.",
    "category": "Keywords",
    "type": "flashcard"
  },
  {
    "question": "final keyword (method)",
    "answer": "The method cannot be overridden by subclasses.",
    "explanation": "Used to prevent altering critical behavior.",
    "category": "Keywords",
    "type": "flashcard"
  },
  {
    "question": "final keyword (class)",
    "answer": "The class cannot be subclassed (extended).",
    "explanation": "e.g., The String class is final.",
    "category": "Keywords",
    "type": "flashcard"
  },
  {
    "question": "Stack Memory",
    "answer": "Memory used for method execution and local variables (references).",
    "explanation": "Short-lived memory. LIFO (Last In First Out).",
    "category": "Memory",
    "type": "flashcard"
  },
  {
    "question": "Heap Memory",
    "answer": "Memory used for storing Objects and Instance Variables.",
    "explanation": "Long-lived memory managed by Garbage Collector.",
    "category": "Memory",
    "type": "flashcard"
  },
  {
    "question": "Garbage Collection",
    "answer": "Automatic memory management that reclaims memory from objects that are no longer reachable.",
    "explanation": "Programmers cannot force it, only suggest it via System.gc().",
    "category": "Memory",
    "type": "flashcard"
  },
  {
    "question": "Cloneable Interface",
    "answer": "A marker interface (empty) indicating that a class allows cloning.",
    "explanation": "If missing, calling clone() throws CloneNotSupportedException.",
    "category": "Cloning",
    "type": "flashcard"
  },
  {
    "question": "Upcasting",
    "answer": "Casting a subclass reference to a superclass reference.",
    "explanation": "Done implicitly. Safe. e.g., `Animal a = new Dog();`",
    "category": "Casting",
    "type": "flashcard"
  },
  {
    "question": "Downcasting",
    "answer": "Casting a superclass reference back to a subclass reference.",
    "explanation": "Must be explicit. Can throw ClassCastException. e.g., `Dog d = (Dog) a;`",
    "category": "Casting",
    "type": "flashcard"
  },
  {
    "question": "Diamond Problem",
    "answer": "Ambiguity arising when a class inherits from two parents that have the same method.",
    "explanation": "Java avoids this in classes but handles it in Interfaces by requiring the implementing class to override the conflict.",
    "category": "Interfaces",
    "type": "flashcard"
  },
  {
    "question": "Varargs",
    "answer": "A feature allowing a method to accept a variable number of arguments.",
    "explanation": "Syntax: `void method(int... nums)`. Internally handled as an array.",
    "category": "Methods",
    "type": "flashcard"
  },
  {
    "question": "Wrapper Classes",
    "answer": "Classes that encapsulate primitive types as Objects (e.g., Integer for int).",
    "explanation": "Allows primitives to be used in Collections (ArrayList<Integer>).",
    "category": "Java Fundamentals",
    "type": "flashcard"
  },
  {
    "question": "instanceof",
    "answer": "An operator used to check if an object is an instance of a specific class or interface.",
    "explanation": "Returns boolean true/false.",
    "category": "Operators",
    "type": "flashcard"
  },
  {
    "question": "static keyword",
    "answer": "Indicates that a member belongs to the class rather than instances.",
    "explanation": "Shared across all objects. Accessed via ClassName.member.",
    "category": "Keywords",
    "type": "flashcard"
  },
  {
    "question": "Abstract Method",
    "answer": "A method declared without a body (implementation).",
    "explanation": "Must be implemented by the first concrete subclass.",
    "category": "Abstraction",
    "type": "flashcard"
  },
  {
    "question": "throw vs throws",
    "answer": "'throw' is used to explicitly throw an exception. 'throws' is used in method signature to declare exceptions.",
    "explanation": "`throw new Exception()` happens inside code; `void method() throws Exception` happens in definition.",
    "category": "Error Handling",
    "type": "flashcard"
  }
]